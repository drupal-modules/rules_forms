<?php

/**
 * @file
 * Rules Forms Support provides events, conditions, and actions for site forms.
 */

define('RULES_FORMS_ADMIN_PATH', 'admin/config/workflow/rules/forms');

/**
 * Implements hook_help().
 */
function rules_forms_help($path, $arg) {
	switch ($path) {
    case 'admin/help#rules_forms':
      return '<p>' . t('Rules Forms Support provides Rules events, conditions, and actions for any form '.
                       'built with the Drupal form API. To activate events for a form you must first '.
                       'visit <a href="!admin">Rules Forms settings</a> and enable activation messages.',
                       array('!admin' => url(RULES_FORMS_ADMIN_PATH))) . '</p>';
    case RULES_FORMS_ADMIN_PATH:
      return '<p>' . t('Settings and overview of form events and active elements.') . '</p>';
  }
}

/**
 * Implements hook_permission().
 */
function rules_forms_permission() {
  return array(
    'administer rules forms rules' => array(
      'title' => t('Administer Rules Forms rules'),
      'description' => t('Grants access to building rules for forms.'),
    ),
    'administer rules forms' => array(
      'title' => t('Administer Rules Forms'),
      'description' => t('Grants access to Rules Forms settings and activating or deactivating rules for forms.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function rules_forms_menu() {
  $items = array();
  $items[RULES_FORMS_ADMIN_PATH] = array(
    'title' => 'Forms Support',
    'description' => 'Manage Rules Forms events, forms, and form element information.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rules_forms_admin_events'),
    'access arguments' => array('administer rules forms'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'file' => 'includes/rules_forms.admin.inc',
  );
  $items[RULES_FORMS_ADMIN_PATH . '/%/activate/%'] = array(
    'title' => 'Activate events for a form',
    'type' => MENU_CALLBACK,
    'page callback' => 'rules_forms_activate',
    'page arguments' => array(5, 7),
    'access arguments' => array('administer rules forms'),
    'file' => 'includes/rules_forms.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_flush_caches().
 */
function rules_forms_flush_caches() {
  db_update('rules_forms')
    ->fields(array('rebuild' => 1))
    ->execute();
  drupal_static_reset('rules_forms_element_property_info');
  return array('cache_rules_forms');
}

/**
 * Implements hook_entity_info().
 */
function rules_forms_entity_info() {
  $return = array();
  $return['form'] = array(
    'label' => t('Form'),
    'module' => 'rules_forms',
    'entity class' => 'RulesFormsArrayEntity',
    'controller class' => 'RulesFormsFormController',
    'rules controller class' => 'RulesFormsRulesController',
    'base table' => 'rules_forms',
    'entity keys' => array(
      'id' => 'fid',
      'name' => 'form_id',
      'bundle' => 'form_id',
    ),
    'bundles' => array(),
  );

  $return['form_state'] = array(
    'label' => t('Form state'),
    'module' => 'rules_forms',
    'entity class' => 'RulesFormsArrayEntity',
    'controller class' => 'RulesFormsFormStateController',
    'rules controller class' => 'RulesFormsRulesController',
    'base table' => 'rules_forms',
    'entity keys' => array(
      'id' => 'fid',
      'name' => 'form_id',
      'bundle' => 'form_id',
    ),
    'bundles' => array(),
  );

  // Each active for is a bundle.
  foreach (rules_forms_get_form_info() as $form_id => $info) {
    $return['form']['bundles'][$form_id] = array(
      'label' => $info['label'],
    );
    $return['form_state']['bundles'][$form_id] = array(
      'label' => $info['label'],
    );
  }
  return $return;
}

/**
 * Implements hook_entity_property_info().
 */
function rules_forms_entity_property_info() {
  $form_info = rules_forms_get_form_info();
  $properties = array(
    'form' => array('bundles' => array()),
    'form_state' => array('bundles' => array()),
  );
  foreach ($form_info as $form_id => $info) {
    $properties['form']['bundles'][$form_id]['properties'] = $info['properties']['form'];
    $properties['form_state']['bundles'][$form_id]['properties'] = $info['properties']['form_state'];
  }
  return $properties;
}

/**
 * Returns defined properties for form elements. Properties are
 * formatted for hook_entity_property_info().
 *
 * @param string|null $type
 *   An optional key specifying which element type's properties
 *   to return.
 *
 * @return array
 *   An array of property for all form element types or for a
 *   specific element type if one was provided.
 */
function rules_forms_element_property_info($type = NULL) {
  $properties = &drupal_static(__FUNCTION__);

  if (!isset($properties)) {
    $properties = module_invoke_all('rules_forms_element_property_info');
    foreach ($properties as $key => $value) {
      foreach ($value as $property => $info) {
        $properties[$key][$property] += array('form element property' => TRUE);
      }
    }
    drupal_alter('rules_forms_element_property_info', $properties);
  }

  if ($type !== NULL) {
    return isset($properties[$type]) ? $properties[$type] : array();
  }
  return $properties;
}

/**
 * Implements hook_rules_forms_element_property_info().
 *
 * Defines an array of form element types that can be accessed
 * in Rules Forms rules and their property info as required by
 * hook_entity_property_info(). This data is used as property
 * info for the individual elements of a form depending on the
 * form element's type. Any element types not listed here will
 * not be accessible in the Rules data selector.
 */
function rules_forms_rules_forms_element_property_info() {
  $common = array(
    '#access' => array(
      'type' => 'boolean',
      'label' => 'access',
      'description' => t('Whether the element is accessible or not; when FALSE, the element is not rendered and the user submitted value is not taken into consideration.'),
    ),
    '#description' => array(
      'type' => 'text',
      'label' => 'description',
      'description' => t('The description of the form element.'),
    ),
    '#disabled' => array(
      'type' => 'boolean',
      'label' => 'disabled',
      'description' => t('Disables (greys out) a form input element.'),
    ),
    '#prefix' => array(
      'type' => 'text',
      'label' => 'prefix',
      'description' => t('Text or markup to include before the form element.'),
    ),
    '#suffix' => array(
      'type' => 'text',
      'label' => 'suffix',
      'description' => t('Text or markup to include after the form element.'),
    ),
    '#title' => array(
      'type' => 'text',
      'label' => 'title',
      'description' => t('The title of the form element.'),
    ),
    '#weight' => array(
      'type' => 'integer',
      'label' => 'weight',
      'description' => t('Used to sort the list of form elements before being output; lower numbers appear before higher numbers.'),
    ),
  );

  $field = array(
    '#default_value' => array(
      'type' => 'text',
      'label' => 'default value',
      'description' => t('The value of the form element that will be displayed or selected initially if the form has not been submitted yet.'),
    ),
    '#field_prefix' => array(
      'type' => 'text',
      'label' => 'field prefix',
      'description' => t('Text or code that is placed directly in front of the textfield.'),
    ),
    '#field_suffix' => array(
      'type' => 'text',
      'label' => 'field suffix',
      'description' => t('Text or code that is placed directly after the textfield.'),
    ),
  );

  $elements = array();
  $elements['item'] = $common;
  $elements['textfield'] = $common + $field;
  $elements['textarea'] = $common + $field;
  $elements['checkbox'] = $common + $field;
  $elements['radio'] = $common + $field;
  $elements['checkboxes'] = $common + $field + array(
    '#options' => array(
      'type' => 'text',
      'label' => 'options',
      'description' => t('Selectable options for a form element that allows multiple choices.'),
    ),
  );
  $elements['radios'] = $common + $field + array(
    '#options' => array(
      'type' => 'text',
      'label' => 'options',
      'description' => t('Selectable options for a form element that allows multiple choices.'),
    ),
  );
  $elements['select'] = $common + $field + array(
    '#multiple' => array(
      'type' => 'boolean',
      'label' => 'allow multiple',
      'description' => t('Indicates whether the user may select more than one item.'),
    ),
    '#options' => array(
      'type' => 'text',
      'label' => 'options',
      'description' => t('Selectable options for a form element that allows multiple choices.'),
    ),
  );
  $elements['fieldset'] = $common + array(
    '#collapsible' => array(
      'type' => 'boolean',
      'label' => 'collapsible',
      'description' => t('Indicates whether or not the fieldset can be collapsed with JavaScript.'),
    ),
    '#collapsed' => array(
      'type' => 'boolean',
      'label' => 'collapsed',
      'description' => t('Indicates whether or not the fieldset is collapsed by default.'),
    ),
  );
  $elements['button'] = $elements['submit'] = $common + array(
    '#value' => array(
      'type' => 'text',
      'label' => 'label',
      'description' => t('The label text of the form element.'),
    ),
  );
  $elements['value'] = array(
    '#value' => array(
      'type' => 'text',
      'label' => 'value',
      'description' => t('A hidden value.'),
    ),
  );

  $defaults = array(
    'computed' => TRUE,
    'getter callback' => 'rules_forms_get_property',
    'setter callback' => 'rules_forms_set_property',
  );
  foreach ($elements as $key => $value) {
    foreach ($value as $property => $info) {
      $elements[$key][$property] += $defaults;
    }
  }

  // Value fields are not settable, buttons don't have descriptions, and items can't be disabled.
  unset($elements['value']['#value']['setter callback']);
  unset($elements['button']['#description'], $elements['submit']['#description'], $elements['item']['#disabled']);

  return $elements;
}

/**
 * Wraps a Rules Form entity with RulesFormsArrayEntity.
 *
 * @param array $entity
 *   The entity to wrap.
 * @param array $info
 *   An optional array of additional info to pass to the wrapper class.
 *
 * @return RulesFormsWrapper
 *   The wrapped entity.
 */
function rules_forms_entity_wrapper(Entity $entity, array $info = array()) {
  if (!class_implements($entity, 'RulesFormsArrayAccess')) {
    throw new EntityMetadataWrapperException('Entity class must implement the RulesFormsArrayAccess interface.');
  }

  $property_info = rules_forms_entity_property_info();
  $info += array('property info' => $property_info[$entity->entityType()]['bundles'][$entity->form_id]['properties']);

  $class = 'RulesForms' . str_replace(' ', '', ucwords(str_replace('_', ' ', $entity->entityType()))) . 'Wrapper';
  if (class_exists($class) && in_array('RulesFormsWrapper', class_parents($class))) {
    return new $class($entity, $info);
  }
  return new RulesFormsDataWrapper($entity->entityType(), $entity, $info);
}

/**
 * Creates a data structure (array).
 */
function rules_forms_create_structure() {
  return array();
}

/**
 * Returns a form element property.
 */
function rules_forms_get_property($element, array $options, $name, $type) {
  return $element[$name];
}

/**
 * Sets a form element property.
 */
function rules_forms_set_property(&$element, $name, $value) {
  $element[$name] = $value;
}

/**
 * Implements hook_form_alter().
 */
function rules_forms_form_alter(&$form, &$form_state, $form_id) {
  $form_info = rules_forms_get_form_info($form_id);

  if ($form_info !== FALSE) {
    // Set elements for form events.
    rules_forms_event_build($form, $form_state, $form_id);
    $form['#validate'][] = 'rules_forms_event_validate';
    $form['#submit'][] = 'rules_forms_event_submit';
    $form['#after_build'][] = 'rules_forms_after_build';

    // @TODO Add button level validate/submit handlers.
  }
  elseif (!empty($_SESSION['rules_forms_message'])) {
    // Display form ID message if enabled for this session.
    $uri = drupal_get_destination();
    $link = l($form_id, RULES_FORMS_ADMIN_PATH . '/' . $form_id . '/activate/'. urlencode(trim($uri['destination'], '/')));
    $msg = t('Activate events for ');
    drupal_set_message($msg . $link, 'status', FALSE);
  }
}

/**
 * Form build handler. Stores form values and invokes the event.
 */
function rules_forms_event_build(&$form, &$form_state, $form_id) {
  // @TODO Save form values on build for comparison against
  // the form_state entity on validate and submit events.
  // Invoke the form_built event.
  rules_forms_invoke_event('form_built', $form, $form_state, $form_id);
}

/**
 * Validation handler to invoke "form validate" events
 *
 * @see rules_forms_form_alter()
 */
function rules_forms_event_validate(&$form, &$form_state) {
  rules_forms_invoke_event('form_validate', $form, $form_state);
}

/**
 * Submit handler to invoke "form submitted" events
 *
 * @see rules_forms_form_alter()
 */
function rules_forms_event_submit(&$form, &$form_state) {
  rules_forms_invoke_event('form_submit', $form, $form_state);
}

/**
 * Invoke rules event of a certain type.
 *
 * @param string $event_type
 *   The type of Rules Forms event being invoked.
 *   - form_built
 *   - form_validate
 *   - form_submit
 *   - button_ELEMENT_ID_validate
 *   - button_ELEMENT_ID_submit
 * @param array $form
 *   A reference to the form array for which the event is being invoked.
 * @param array $form_state
 *   A reference to the form state array for which the event is being invoked.
 * @param string|null $form_id
 *   The form ID of the form for which the event is being invoked, or NULL. If
 *   NULL the form ID will be retrieved from the $form array.
 *
 * @see rules_forms_event_validate()
 * @see rules_forms_event_submit()
 * @see rules_forms_form_alter()
 */
function rules_forms_invoke_event($event_type, &$form, &$form_state, $form_id = NULL) {
  if (empty($form_id)) {
    $form_id = $form['form_id']['#value'];
  }

  // Prepare and wrap form data for passage to Rules.
  try {
    $form_wrapped = rules_forms_entity_wrapper(new RulesFormsArrayEntity('form', $form_id, $form));
    $form_state_wrapped = rules_forms_entity_wrapper(new RulesFormsArrayEntity('form_state', $form_id, $form_state));
  }
  catch (EntityMetadataWrapperException $e) {
    rules_log($e->getMessage(), array(), RulesLog::ERROR);
  }

  rules_invoke_event("rules_forms_{$form_id}_{$event_type}", $form_wrapped, $form_state_wrapped);

  // Repopulate form arrays to update the form.
  $form = (array) $form_wrapped->value()->getArray();
  $form_state = (array) $form_state_wrapped->value()->getArray();
}

/**
 * Evaluates element property information if necessary.
 */
function rules_forms_after_build($form, &$form_state) {
  $form_id = $form['form_id']['#value'];
  $form_info = rules_forms_get_form_info($form_id);

  // Ensure that the form ID matches an activated form's form ID to prevent
  // improper Rules events from being loaded in hook_rules_event_info().
  if ($form_info !== FALSE && (!empty($form_info['rebuild']))
      || (!isset($form_info['properties']) || empty($form_info['properties']))) {
    if (!empty($form_info['rebuild'])) {
      $form_info['rebuild'] = FALSE;
    }

    // Note: This call to retrieve element property info is a hacky fix to
    // that function's return. When calling the function right after the cache
    // is cleared, a small and invalid portion of the property info array is returned.
    // We have to call it first here to let it cache the correct array so when it's
    // called when building form elements it returns accurate results.
    rules_forms_element_property_info();
    $form_info['properties']['form'] = array();
    $form_info['properties']['form_state']['values'] = array(
      'type' => 'struct',
      'label' => 'values',
      'computed' => TRUE,
      'getter callback' => 'rules_forms_get_property',
      'auto creation' => 'rules_forms_create_structure',
      'property info' => array(),
    );

    rules_forms_build_element_property_info($form, $form_info['properties']['form'], $form_info['properties']['form_state']['values']['property info']);
    rules_forms_save_form_info($form_id, $form_info, TRUE);
    drupal_set_message(t('Form elements for %form have been built.', array('%form' => $form_info['label'])));
  }
  // @TODO Consider adding the element inspection tool.
  return $form;
}

/**
 * Builds an associative array of property info as required in
 * hook_entity_property_info(). The array is built by recursively
 * reading the form array.
 *
 * @param array $form
 *   The form array containing elements from which property info
 *   is derived.
 * @param array $properties
 *   The properties array.
 */
function rules_forms_build_element_property_info($form, &$form_properties, &$form_state_properties, $tree = FALSE) {
  $element_properties = rules_forms_element_property_info();
  foreach (element_children($form) as $key) {
    if (isset($form[$key]['#type']) && array_key_exists($form[$key]['#type'], $element_properties)) {
      $form_properties[$key] = array(
        'type' => 'struct',
        'label' => isset($form[$key]['#title']) ? "{$form[$key]['#type']}: {$form[$key]['#title']}" : $form[$key]['#type'],
        'computed' => TRUE,
        'getter callback' => 'rules_forms_get_property',
        'setter callback' => 'rules_forms_set_property',
        'auto creation' => 'rules_forms_create_structure',
        'property info' => $element_properties[$form[$key]['#type']],
      );

      $is_tree = ($tree == TRUE || !empty($form[$key]['#tree']));
      $form_state_properties[$key] = array(
        'label' => isset($form[$key]['#title']) ? "{$form[$key]['#type']}: {$form[$key]['#title']}" : $form[$key]['#type'],
        'computed' => TRUE,
        'getter callback' => 'rules_forms_get_property',
      );

      // If this is a tree then property info needs to be stored as such.
      $children = element_children($form[$key]);
      if ($is_tree && !empty($children)) {
        $form_state_properties[$key]['type'] = 'struct';
        $form_state_properties['property info'] = array();
        $form_state_arg = &$form_state_properties['property info'];
      }
      else {
        $form_state_properties[$key]['type'] = 'text';
        $form_state_properties[$key]['form element property'] = TRUE;
        $form_state_arg = &$form_state_properties;
      }
      rules_forms_build_element_property_info($form[$key], $form_properties[$key]['property info'], $form_state_arg, $is_tree);
    }
  }
}

/**
 * Returns form information.
 *
 * @param string|array $form_id
 *   An optional form ID or $form array from which the form ID can be retrieved.
 *
 * @return array|false
 *   An array of forms and their information keyed by form IDs. Or,
 *   if a form ID is specified then that form's information is returned.
 *   Returns boolean FALSE if a form array without the form ID was passed.
 */
function rules_forms_get_form_info($form_id = NULL) {
  $form_info = array();
  if ($cache = cache_get('form_info', 'cache_rules_forms')) {
    $form_info = $cache->data;
  }

  if (empty($form_info)) {
    $result = db_select('rules_forms', 'rf')
      ->fields('rf')
      ->execute();

    foreach ($result as $info) {
      $form_info[$info->form_id] = (array) $info;
      $form_info[$info->form_id]['properties'] = unserialize($info->properties);
    }
    cache_set('form_info', $form_info, 'cache_rules_forms');
  }

  if ($form_id === NULL) {
    return $form_info;
  }

  // Allow the passage of a $form array.
  if (!is_string($form_id)) {
    if (isset($form_id['form_id'])) {
      $form_id = $form_id['form_id']['#value'];
    }
    else {
      return FALSE;
    }
  }
  return isset($form_info[$form_id]) ? $form_info[$form_id] : FALSE;
}

/**
 * Saves form information.
 *
 * @param string $form_id
 *   The form ID of the form whose information is being saved.
 * @param array $form_info
 *   The form information to store.
 * @param bool $update
 *   Indicates whether this is an update.
 * @param bool $rebuild_cache
 *   A boolean value indicating whether the Rules cache should be reset
 *   upon saving. This defaults to TRUE.
 */
function rules_forms_save_form_info($form_id, array $form_info, $update = FALSE, $rebuild_cache = TRUE) {
  $form_info['properties'] = serialize($form_info['properties']);
  $info = array(
    'form_id' => $form_id,
    'label' => $form_info['label'],
    'properties' => $form_info['properties'],
    'rebuild' => $form_info['rebuild'] == TRUE ? 1 : 0,
  );

  if ($update) {
    $result = db_update('rules_forms')
      ->fields($info)
      ->condition('form_id', $form_id, '=')
      ->execute();
  }
  else {
    $result = db_insert('rules_forms')
      ->fields($info)
      ->execute();
  }

  if ($rebuild_cache) {
    rules_clear_cache();
    cache_clear_all('*', 'cache_rules_forms', TRUE);
  }
  return $update ? SAVED_UPDATED : SAVED_NEW;
}

/**
 * Activate events for a form.
 */
function rules_forms_activate_form($form_id, $form_info) {
  rules_forms_save_form_info($form_id, $form_info, FALSE, FALSE);
}

/**
 * Deactivate events for a form.
 */
function rules_forms_deactivate_form($form_id) {
  $num = db_delete('rules_forms')
    ->condition('form_id', $form_id)
    ->execute();
  return SAVED_DELETED;
}
